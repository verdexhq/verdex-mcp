# Bundled Bridge Injection — Implementation Plan (Authoritative)

**Branch**: `feature/bundled-bridge-injection`
**Status**: Ready to Execute
**Created**: 2025-10-22

---

## Overview

Migrate from brittle `toString()` string-eval to a **pre-bundled bridge** that is **auto-injected** into a **named isolated world** via **Chrome DevTools Protocol (CDP)**. The injector is **event-driven**, **versioned**, **survives navigation (with fallbacks for older Chromium)**, and **cleans up deterministically**.
Tests are split by responsibility: **Puppeteer for injector (CDP) unit tests**, **Playwright for integration** (selector behavior and isolation).

---

## Pre-Implementation Checklist

* [x] Documentation committed
* [x] Branch confirmed: `feature/bundled-bridge-injection`
* [x] Current architecture analyzed
* [x] Migration plan reviewed
* [ ] Implementation ready to begin

---

## Phase 1 — Bundle Infrastructure (Foundation)

### Task 1.1 — Install Build Dependencies ⏱️ 2 min

```bash
npm install --save-dev esbuild tsx
```

**Verify**

* `esbuild`, `tsx` present in `devDependencies`.

### Task 1.2 — Create Bundling Script ⏱️ 10–15 min

**File**: `build/bundle-bridge.ts`

**Requirements**

* Entry: `src/injected/bridge-entry.ts`
* Output: `src/injection/bridge-bundle.ts` (committed to repo)
* Bundle **all** deps (BridgeFactory, SnapshotGenerator, etc.)
* Define `__VERSION__` from `package.json.version`
* **IIFE** format, **target `es2020`**
* **Dev**: inline sourcemaps; **Prod**: external sourcemaps, minified
* Banner (version + timestamp)
* **Bundle size guard**: **fail build if > 100 KB**

**Template**

```ts
import * as esbuild from 'esbuild';
import * as fs from 'fs';
import * as path from 'path';

const DEV = process.env.NODE_ENV !== 'production';
const outFile = path.join(__dirname, '../src/injection/bridge-bundle.ts');

function getVersion(): string {
  const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
  return pkg.version;
}

async function main() {
  const version = getVersion();

  const result = await esbuild.build({
    entryPoints: ['src/injected/bridge-entry.ts'],
    bundle: true,
    format: 'iife',
    platform: 'browser',
    target: 'es2020',
    minify: !DEV,
    sourcemap: DEV ? 'inline' : 'external',
    sourcesContent: DEV,
    banner: {
      js: [
        `// Verdex Bridge Bundle v${version}`,
        `// Generated: ${new Date().toISOString()}`,
      ].join('\n'),
    },
    define: {
      __VERSION__: JSON.stringify(version),
    },
    write: false,
  });

  const bundleCode = result.outputFiles[0].text;

  // Size guard (100 KB in production only; dev includes inline sourcemaps)
  const bytes = Buffer.byteLength(bundleCode, 'utf8');
  if (!DEV && bytes > 100 * 1024) {
    console.error(`❌ Bridge too large: ${(bytes / 1024).toFixed(1)} KB (limit 100 KB)`);
    process.exit(1);
  }

  const module = `/**
 * Auto-generated bridge bundle
 * DO NOT EDIT - Generated by build/bundle-bridge.ts
 */
export const BRIDGE_BUNDLE = ${JSON.stringify(bundleCode)};
export const BRIDGE_VERSION = ${JSON.stringify(version)};
`;

  fs.writeFileSync(outFile, module, 'utf8');
  console.log(`✅ Bridge bundle generated (${(bytes/1024).toFixed(1)} KB) v${version}${DEV ? ' [dev]' : ''}`);
}

main().catch((err) => { console.error(err); process.exit(1); });
```

### Task 1.3 — Create Bridge Entry Point ⏱️ 15 min

**File**: `src/injected/bridge-entry.ts`

**Requirements**

* **Declare** the version symbol for TypeScript.
* Import factory and types using **ESM `.js`** suffixes.
* **Export** `__VERDEX_BRIDGE_VERSION__` and `createBridge(config?)`.
* **Expose factory only** into the isolated world: `globalThis.__VerdexBridgeFactory__ = { create, version }`.

**Template**

```ts
/* Browser-only entry for bundled bridge */
declare const __VERSION__: string;

import { BridgeFactory } from './bridge/BridgeFactory.js';
import type { BridgeConfig, IBridge } from './types/index.js';

export const __VERDEX_BRIDGE_VERSION__ = __VERSION__;

export function createBridge(config?: BridgeConfig): IBridge {
  return BridgeFactory.create(config);
}

(function expose() {
  const g = globalThis as any;
  g.__VerdexBridgeFactory__ = {
    create: createBridge,
    version: __VERDEX_BRIDGE_VERSION__,
  };
})();
```

### Task 1.4 — Ensure Injection Directory ⏱️ 1 min

```bash
mkdir -p src/injection
```

### Task 1.5 — Update NPM Scripts ⏱️ 3 min

**`package.json`**

```json
{
  "scripts": {
    "prebuild": "NODE_ENV=production tsx build/bundle-bridge.ts",
    "prebuild:dev": "NODE_ENV=development tsx build/bundle-bridge.ts",
    "build": "npm run prebuild && rm -rf dist && tsc",
    "dev": "npm run prebuild:dev && tsx src/index.ts",
    "bundle:watch": "NODE_ENV=development tsx --watch build/bundle-bridge.ts",
    "test": "YOUR_TEST_COMMAND"
  }
}
```

### Task 1.6 — Generate Initial Bundle ⏱️ 2 min

```bash
npm run prebuild
```

**Verify**

* `src/injection/bridge-bundle.ts` exists
* Exports `BRIDGE_BUNDLE`, `BRIDGE_VERSION`
* Size < 100KB (else build fails)
* Version matches `package.json`

**Phase 1 Completion**

* [ ] Files created
* [ ] Bundle generated
* [ ] No TS errors
* [ ] Size guard enforced
* [ ] Version embedded

---

## Phase 2 — Bridge Injector (CDP Integration)

### Task 2.1 — Implement `BridgeInjector` ⏱️ 60–90 min

**File**: `src/injection/BridgeInjector.ts`

**Architecture**

```
BridgeInjector
├─ Listeners (register BEFORE enable)
│  ├─ Runtime.executionContextCreated
│  ├─ Page.frameStartedLoading
│  ├─ Page.navigatedWithinDocument
│  └─ Page.frameNavigated
├─ Auto-injection (robust)
│  ├─ try addScriptToEvaluateOnNewDocument({ worldName, runImmediately: true })
│  ├─ retry without runImmediately
│  └─ if both fail → manualInjectionMode (per-navigation reinjection)
├─ Context tracking
│  ├─ contextId, bridgeObjectId, navigationInProgress
│  └─ contextReadyResolvers[]
├─ Guards
│  ├─ waitForContextReady(3000ms)
│  └─ waitForNavToClear(10000ms)
└─ Lifecycle
   ├─ setupAutoInjection()
   ├─ getBridgeHandle()
   ├─ callBridgeMethod()
   ├─ healthCheck()
   ├─ reset()
   └─ dispose() // removes auto-script + listeners (before cdp.detach)
```

**Key Details & Choices**

* **World name**: `verdex_${role}_${(process.pid ?? Math.floor(Math.random()*100000)) % 1000}` (salt prevents collisions across roles/processes)
* **grantUniveralAccess**: **false** (keep isolation tight; note CDP's historical misspelling)
* **Timeouts**: context ready **3000ms**, navigation clear **10000ms**
* **Listener cleanup**: Store `{event, handler}` pairs; remove them in `dispose()`
* **SPA handling**: Same-document navs invalidate instance handle but do NOT block calls
* **Async bridge methods**: Use `awaitPromise: true` in CDP calls for Promise-returning methods

**Skeleton (core excerpts)**

```ts
import type { CDPSession } from 'puppeteer';
import { BRIDGE_BUNDLE, BRIDGE_VERSION } from './bridge-bundle.js';
import type { BridgeConfig } from '../types.js';

export type InjectorOptions = {
  worldName?: string;
  config?: BridgeConfig;
  mainFrameId?: string;
};

export class BridgeInjector {
  private worldName: string;
  private config: BridgeConfig;
  private mainFrameId: string | null = null;
  private contextId: number | null = null;
  private bridgeObjectId: string | null = null;
  private navigationInProgress = false;
  private contextReadyResolvers: Array<() => void> = [];
  private scriptId: string | null = null;
  private manualInjectionMode = false;
  private listeners: Array<{ event: string; handler: Function }> = [];

  constructor(options: InjectorOptions = {}) {
    this.worldName = options.worldName ?? 'verdex_isolated';
    this.config = options.config ?? {};
    if (options.mainFrameId) this.mainFrameId = options.mainFrameId;
  }

  private addListener(cdp: CDPSession, event: string, handler: Function) {
    (cdp as any).on(event, handler);
    this.listeners.push({ event, handler });
  }

  async setupAutoInjection(cdp: CDPSession, mainFrameId: string): Promise<void> {
    this.mainFrameId = mainFrameId;

    const onCtx = (evt: any) => {
      const ctx = evt.context;
      const aux = ctx.auxData ?? {};
      const matchesWorld = ctx.name === this.worldName || aux.name === this.worldName;
      const matchesTop = !this.mainFrameId || aux.frameId === this.mainFrameId;
      if (matchesWorld && matchesTop) {
        this.contextId = ctx.id;
        this.navigationInProgress = false;
        this.resolveContextReady();
      }
    };
    const onStart = (evt: any) => { if (this.isTopFrame(evt.frameId)) this.onTopFrameNavigating(); };
    const onSameDoc = (evt: any) => {
      if (this.isTopFrame(evt.frameId)) {
        // SPA route change: keep context alive, just invalidate instance handle
        // DO NOT set navigationInProgress (would stall calls for 10s)
        this.bridgeObjectId = null;
      }
    };
    const onNav = (evt: any) => {
      if (evt.frame && this.isTopFrame(evt.frame.id) && !evt.frame.parentId) this.onTopFrameNavigating();
    };

    // LISTENERS FIRST
    this.addListener(cdp, 'Runtime.executionContextCreated', onCtx);
    this.addListener(cdp, 'Page.frameStartedLoading', onStart);
    this.addListener(cdp, 'Page.navigatedWithinDocument', onSameDoc);
    this.addListener(cdp, 'Page.frameNavigated', onNav);

    // THEN enable
    await cdp.send('Page.enable');
    await cdp.send('Runtime.enable');

    // Auto-inject: try with runImmediately first, then without; fallback to manual mode
    try {
      const { identifier } = await cdp.send('Page.addScriptToEvaluateOnNewDocument', {
        source: BRIDGE_BUNDLE,
        worldName: this.worldName,
        runImmediately: true
      });
      this.scriptId = identifier;
    } catch {
      try {
        const { identifier } = await cdp.send('Page.addScriptToEvaluateOnNewDocument', {
          source: BRIDGE_BUNDLE,
          worldName: this.worldName
        });
        this.scriptId = identifier;
      } catch {
        // Very old Chromium: fallback to manual per-navigation reinjection
        this.manualInjectionMode = true;
      }
    }

    // Ensure current doc is covered quickly
    let appeared = false;
    try { await this.waitForContextReady(500); appeared = true; } catch {}
    if (!appeared) await this.injectOnceIntoCurrentDoc(cdp);

    // Manual reinjection mode ONLY if addScriptToEvaluateOnNewDocument unavailable
    if (this.manualInjectionMode) {
      const reinject = async (evt: any) => {
        if (evt.frame && this.isTopFrame(evt.frame.id) && !evt.frame.parentId) {
          try { await this.injectOnceIntoCurrentDoc(cdp); } catch {}
        }
      };
      this.addListener(cdp, 'Page.frameNavigated', reinject);
    }
  }

  private async injectOnceIntoCurrentDoc(cdp: CDPSession): Promise<void> {
    const { executionContextId } = await cdp.send('Page.createIsolatedWorld', {
      frameId: this.mainFrameId!,
      worldName: this.worldName,
      grantUniveralAccess: false
    });
    await cdp.send('Runtime.evaluate', {
      expression: BRIDGE_BUNDLE,
      contextId: executionContextId,
      returnByValue: false
    });
  }

  private isTopFrame(frameId?: string): boolean {
    return !!this.mainFrameId && frameId === this.mainFrameId;
  }

  private onTopFrameNavigating() {
    this.navigationInProgress = true;
    this.contextId = null;
    this.bridgeObjectId = null;
  }

  private async waitForContextReady(timeoutMs = 3000): Promise<void> {
    if (this.contextId && !this.navigationInProgress) return;
    let timeout: NodeJS.Timeout | null = null;
    await new Promise<void>((resolve, reject) => {
      const done = () => { if (timeout) clearTimeout(timeout); resolve(); };
      this.contextReadyResolvers.push(done);
      timeout = setTimeout(() => reject(new Error(`Isolated world '${this.worldName}' not ready`)), timeoutMs);
    });
  }

  private resolveContextReady() {
    const resolvers = this.contextReadyResolvers.splice(0);
    resolvers.forEach((fn) => fn());
  }

  private async waitForNavToClear(maxWaitMs = 10000): Promise<void> {
    if (!this.navigationInProgress) return;
    const start = Date.now();
    while (this.navigationInProgress && Date.now() - start < maxWaitMs) {
      await new Promise((r) => setTimeout(r, 50));
    }
    if (this.navigationInProgress) throw new Error('Bridge unavailable: navigation taking too long');
  }

  async getBridgeHandle(cdp: CDPSession): Promise<string> {
    await this.waitForNavToClear();
    if (this.bridgeObjectId) {
      if (await this.healthCheck(cdp)) return this.bridgeObjectId;
      this.bridgeObjectId = null;
    }
    await this.waitForContextReady();
    if (!this.contextId) throw new Error('No execution context available for the bridge world');

    const { result: typeRes } = await cdp.send('Runtime.evaluate', {
      expression: 'typeof globalThis.__VerdexBridgeFactory__',
      contextId: this.contextId,
      returnByValue: true
    });
    if (typeRes.value !== 'object') throw new Error('Bridge factory not available in context');

    const { result: verRes } = await cdp.send('Runtime.evaluate', {
      expression: 'globalThis.__VerdexBridgeFactory__?.version',
      contextId: this.contextId,
      returnByValue: true
    });
    if (verRes.value !== BRIDGE_VERSION) {
      throw new Error(`Version mismatch: got ${verRes.value}, expected ${BRIDGE_VERSION}`);
    }

    const { result } = await cdp.send('Runtime.evaluate', {
      expression: `(function(config){ return globalThis.__VerdexBridgeFactory__.create(config); })(${JSON.stringify(this.config)})`,
      contextId: this.contextId,
      returnByValue: false
    });
    if (!result.objectId) throw new Error('Failed to create bridge instance');

    this.bridgeObjectId = result.objectId;
    return this.bridgeObjectId;
  }

  async callBridgeMethod<T = any>(cdp: CDPSession, method: string, args: any[] = []): Promise<T> {
    await this.waitForNavToClear();
    const objectId = await this.getBridgeHandle(cdp);
    const response = await cdp.send('Runtime.callFunctionOn', {
      functionDeclaration: `
        function(...args) {
          const fn = this?.[${JSON.stringify(method)}];
          if (typeof fn !== 'function') throw new Error('Bridge method not found: ' + ${JSON.stringify(method)});
          return fn.apply(this, args);
        }
      `,
      objectId,
      arguments: args.map((v) => ({ value: v })),
      returnByValue: true,
      awaitPromise: true  // Handle async bridge methods correctly
    });

    if ((response as any).exceptionDetails) {
      const d = (response as any).exceptionDetails;
      throw new Error(d.exception?.description || d.text || 'Bridge method call failed');
    }
    return (response as any).result.value as T;
  }

  async healthCheck(cdp: CDPSession): Promise<boolean> {
    try {
      if (!this.contextId) return false;
      const { result } = await cdp.send('Runtime.evaluate', {
        expression: `globalThis.__VerdexBridgeFactory__?.version === ${JSON.stringify(BRIDGE_VERSION)}`,
        contextId: this.contextId,
        returnByValue: true
      });
      return result.value === true;
    } catch { return false; }
  }

  reset(): void {
    this.navigationInProgress = true;
    this.contextId = null;
    this.bridgeObjectId = null;
  }

  async dispose(cdp: CDPSession): Promise<void> {
    // Remove auto-injected script
    if (this.scriptId) {
      try { await cdp.send('Page.removeScriptToEvaluateOnNewDocument', { identifier: this.scriptId }); } catch {}
      this.scriptId = null;
    }
    // Remove all registered listeners (critical: prevents memory leaks)
    for (const { event, handler } of this.listeners) {
      try { (cdp as any).off?.(event, handler) ?? (cdp as any).removeListener?.(event, handler); } catch {}
    }
    this.listeners = [];
  }
}
```

**Success Criteria**

* [ ] Listeners registered before `Page.enable`/`Runtime.enable`
* [ ] Auto-inject works; retry without `runImmediately` works; **manual reinjection mode** works
* [ ] Context discovery via `Runtime.executionContextCreated`
* [ ] Guards time out predictably
* [ ] `dispose()` removes script and listeners

### Task 2.2 — Injector Unit Test (Puppeteer-only) ⏱️ 15–20 min

**File**: `tests/injector/injector-basic.pup.spec.ts`
*(Run with your Node/Jest/Mocha harness — do not import `@playwright/test` here.)*

```ts
import puppeteer from 'puppeteer';
import assert from 'node:assert/strict';
import { BridgeInjector } from '../../src/injection/BridgeInjector';

describe('BridgeInjector (Puppeteer)', () => {
  it('creates and tracks context', async () => {
    const browser = await puppeteer.launch({ headless: 'new' });
    const page = await browser.newPage();

    const cdp = (page as any).createCDPSession
      ? await (page as any).createCDPSession()
      : await page.target().createCDPSession();

    const { frameTree } = await cdp.send('Page.getFrameTree');
    const mainFrameId = frameTree.frame.id;

    const injector = new BridgeInjector({ worldName: 'test_world', mainFrameId });

    await injector.setupAutoInjection(cdp, mainFrameId);
    await page.goto('about:blank');

    assert.equal(await injector.healthCheck(cdp), true);

    await injector.dispose(cdp);
    await cdp.detach();
    await browser.close();
  });
});
```

**Verification**

* Test passes
* No memory leaks
* Context discovered correctly
* Health check true

---

## Phase 3 — Integration (Wire into MultiContextBrowser)

> This section includes **exact** edit operations. If your file line numbers differ, treat these as replace/remove “blocks”.

### Task 3.1 — Update `RoleContext` type ⏱️ 5 min

**File**: `src/types.ts`

```ts
import type { BridgeInjector } from './injection/BridgeInjector.js';

export type RoleContext = {
  role: string;
  browserContext: BrowserContext;
  page: Page;
  cdpSession: CDPSession;
  bridgeInjector: BridgeInjector;   // NEW (replaces isolatedWorldId, bridgeObjectId)
  mainFrameId: string;
  defaultUrl?: string;
  createdAt: number;
  lastUsed: number;
  hasNavigated: boolean;
  storageStatePath?: string;        // Optional: for persistent role storage
};
```

**Remove**

* `isolatedWorldId: number | null;`
* `bridgeObjectId: string | null;`

### Task 3.2 — Update imports ⏱️ 3 min

**File**: `src/multi-context-browser.ts`

**Remove**

```ts
import { injectedCode } from './injected/index.js';
```

**Add**

```ts
import { BridgeInjector } from './injection/BridgeInjector.js';
```

### Task 3.3 — Replace `_setupRoleContext` ⏱️ 15 min

**File**: `src/multi-context-browser.ts` (replace entire method body)

```ts
private async _setupRoleContext(
  role: string,
  browserContext: BrowserContext,
  page: Page
): Promise<RoleContext> {
  const cdpSession = await page.createCDPSession();
  const { frameTree } = await cdpSession.send('Page.getFrameTree');
  const mainFrameId = frameTree.frame.id;

  const salt = (process.pid ?? Math.floor(Math.random()*100000)) % 1000;
  const bridgeInjector = new BridgeInjector({
    worldName: `verdex_${role}_${salt}`,
    config: this.bridgeConfig,
    mainFrameId,
  });

  await bridgeInjector.setupAutoInjection(cdpSession, mainFrameId);

  const defaultUrl = this.rolesConfig?.roles[role]?.defaultUrl;

  const context: RoleContext = {
    role,
    browserContext,
    page,
    cdpSession,
    bridgeInjector,
    mainFrameId,
    defaultUrl,
    createdAt: Date.now(),
    lastUsed: Date.now(),
    hasNavigated: false,
  };

  // Optional: belt-and-braces reset on top-frame nav
  cdpSession.on('Page.frameNavigated', (event: any) => {
    if (event.frame.id === mainFrameId && !event.frame.parentId) {
      context.bridgeInjector.reset();
    }
  });

  return context;
}
```

### Task 3.4 — Replace `ensureBridgeForContext` ⏱️ 5 min

**File**: `src/multi-context-browser.ts`

```ts
private async ensureBridgeForContext(context: RoleContext): Promise<void> {
  try {
    const healthy = await context.bridgeInjector.healthCheck(context.cdpSession);
    if (!healthy) { /* getBridgeHandle will recreate */ }
    await context.bridgeInjector.getBridgeHandle(context.cdpSession);
  } catch (err) {
    throw new Error(
      `Failed to ensure bridge for role '${context.role}': ${
        err instanceof Error ? err.message : String(err)
      }`
    );
  }
}
```

### Task 3.5 — Delete legacy `_setupIsolatedWorldForContext` ⏱️ 1 min

**File**: `src/multi-context-browser.ts`

* Remove the method entirely:

```ts
// private async _setupIsolatedWorldForContext(...) { ... }
```

### Task 3.6 — Route **all** bridge calls through the injector ⏱️ 20–30 min

**File**: `src/multi-context-browser.ts`

For these 7 methods, replace the existing `Runtime.callFunctionOn` (using `bridgeObjectId`) with the injector call pattern:

**Pattern**

```ts
return await context.bridgeInjector.callBridgeMethod<T>(
  context.cdpSession,
  '<methodName>',
  [/* args */]
);
```

**Methods to update**

1. `snapshot()`
2. `click(ref)`
3. `type(ref, text)`
4. `inspect(ref)`
5. `get_ancestors(ref)`
6. `get_siblings(ref, level)`
7. `get_descendants(ref, level)`

**Example: `snapshot()`**

```ts
async snapshot(): Promise<Snapshot> {
  try {
    const context = await this.ensureCurrentRoleContext();
    await this.ensureBridgeForContext(context);
    return await context.bridgeInjector.callBridgeMethod<Snapshot>(
      context.cdpSession,
      'snapshot'
    );
  } catch (error) {
    throw new Error(
      `Snapshot failed for role '${this.currentRole}': ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}
```

**Example: `click(ref)`**

```ts
async click(ref: string): Promise<void> {
  const context = await this.ensureCurrentRoleContext();
  await this.ensureBridgeForContext(context);

  try {
    await context.bridgeInjector.callBridgeMethod(
      context.cdpSession,
      'click',
      [ref]
    );
  } catch (error) {
    throw new Error(error instanceof Error ? error.message : 'Element not found');
  }
  await new Promise((r) => setTimeout(r, 500));
}
```

*(Repeat similarly for the other five methods; keep return types unchanged.)*

### Task 3.7 — Remove manual bridge invalidations ⏱️ 10 min

**File**: `src/multi-context-browser.ts`

**Search & remove** any occurrences of:

* `context.isolatedWorldId = null;`
* `context.bridgeObjectId = null;`

**Also remove** the **old CDP listener** whose only purpose was manual invalidation.

**Keep**:

* `context.hasNavigated = true;` in `navigate()` / `selectRole()`.

### Task 3.8 — Correct cleanup order ⏱️ 5 min

**File**: `src/multi-context-browser.ts` (`_closeRoleContext`)

**Replace method body** with:

```ts
private async _closeRoleContext(
  role: string,
  contextPromise: Promise<RoleContext>
): Promise<void> {
  try {
    const context = await contextPromise;

    // Cleanup order: Injector -> CDP -> Page -> BrowserContext
    if (context.bridgeInjector) {
      await context.bridgeInjector.dispose(context.cdpSession);
    }
    if (context.cdpSession) {
      await context.cdpSession.detach();
    }
    if (context.page && !context.page.isClosed()) {
      await context.page.close();
    }
    if (context.browserContext) {
      await context.browserContext.close();
    }

    console.log(`✅ Closed context for role: ${role}`);
  } catch (error) {
    console.error(`❌ Failed to close context for role ${role}:`, error);
  }
}
```

### Task 3.9 — Build & fix TS errors ⏱️ 15 min

```bash
npm run build
```

**Resolve** any path/type/export issues.

---

## Phase 4 — Cleanup & Documentation

### Task 4.1 — Remove old injection file ⏱️ 1 min

```bash
rm src/injected/index.ts
```

**Verify**

* No imports left referring to it
* Build still passes

### Task 4.2 — Add JSDoc to `BridgeInjector` ⏱️ 10–15 min

Document:

* Class purpose
* Constructor options
* Method params/returns/throws
* Private helpers
* Example snippet for typical usage

### Task 4.3 — Update README ⏱️ 15 min

**Add**

```markdown
## Architecture — Bridge Injection (CDP, Isolated World)

- Event-driven context tracking via `Runtime.executionContextCreated`
- Auto-injection with `Page.addScriptToEvaluateOnNewDocument`
- Robust fallback for older Chromium (manual per-navigation reinjection)
- Survives navigation & SPA transitions
- Version verification (`BRIDGE_VERSION`) and health checks
- Deterministic cleanup (remove auto-script + listeners)
- Bundle size guard (100 KB) and dev sourcemaps
```

**Remove/replace**

* All mentions of `toString()` serialization
* Add bundling workflow and committing `src/injection/bridge-bundle.ts`

### Task 4.4 — Generate & commit bundle ⏱️ 2 min

```bash
npm run prebuild
git add src/injection/bridge-bundle.ts
```

---

## Phase 5 — Testing & Validation

### Task 5.1 — Run existing tests ⏱️ 5 min

```bash
npm test
```

### Task 5.2 — Injector Unit Tests (Puppeteer) ⏱️ 15–20 min

**We already added** `tests/injector/injector-basic.pup.spec.ts`.
Add more cases as needed (e.g., manual reinjection mode by emulating old Chromium behaviors if possible).

### Task 5.3 — Integration Tests (Playwright) ⏱️ 20–30 min

**File**: `tests/integration/bundled-injection.spec.ts`
(Use Playwright to validate **consumer** behavior: survival across navigation, isolation, multi-role.)

```ts
import { test, expect } from '@playwright/test';
import { MultiContextBrowser } from '../../src/multi-context-browser';

test('bundled bridge survives navigation', async () => {
  const browser = new MultiContextBrowser();
  await browser.initialize();

  await browser.navigate('https://example.com');
  const snapshot1 = await browser.snapshot();
  expect(snapshot1.text).toContain('Example Domain');

  await browser.navigate('https://example.org');
  const snapshot2 = await browser.snapshot();
  expect(snapshot2.text).toContain('Example Domain');

  const context = await (browser as any).ensureCurrentRoleContext();
  const healthy = await context.bridgeInjector.healthCheck(context.cdpSession);
  expect(healthy).toBe(true);

  await browser.close();
});

test('bridge isolated from main world', async () => {
  const browser = new MultiContextBrowser();
  await browser.initialize();
  await browser.navigate('https://example.com');

  const context = await (browser as any).ensureCurrentRoleContext();
  const factoryInMain = await context.page.evaluate(() => {
    return typeof (globalThis as any).__VerdexBridgeFactory__;
  });
  expect(factoryInMain).toBe('undefined');

  await browser.close();
});

test('multi-role context isolation', async () => {
  const browser = new MultiContextBrowser();
  await browser.initialize();

  await browser.navigate('https://example.com');
  const snapshot1 = await browser.snapshot();

  await browser.selectRole('test-role');
  await browser.navigate('https://example.org');
  const snapshot2 = await browser.snapshot();

  await browser.selectRole('default');
  const snapshot3 = await browser.snapshot();

  expect(snapshot3.text).toContain(snapshot1.text);

  await browser.close();
});
```

### Task 5.4 — Manual Validation Checklist ⏱️ 30 min

1. **Basic Navigation**

   * [ ] Multi-page navigation works; snapshots OK
   * [ ] Bridge persists across page transitions

2. **SPA Navigation**

   * [ ] Single-page routes don’t require re-injection on modern Chrome

3. **Role Switching**

   * [ ] Role contexts isolated (cookies/storage)
   * [ ] Independent bridges per role

4. **Reload**

   * [ ] Hard reload re-establishes bridge

5. **Bridge Methods**

   * [ ] `snapshot`, `click`, `type`, `inspect`, `get_ancestors`, `get_siblings`, `get_descendants` OK

6. **Error Handling**

   * [ ] Invalid ref throws cleanly
   * [ ] Navigation timeout surfaces helpful error
   * [ ] Bridge recreation works after failure

7. **Cleanup**

   * [ ] No dangling CDP sessions or listeners
   * [ ] Dispose order correct

8. **Debuggability (dev)**

   * [ ] Inline sourcemaps working
   * [ ] Breakpoints hit bundled sources

9. **Security**

   * [ ] Factory not in main world
   * [ ] No cross-context leaks

10. **Performance**

    * [ ] Latency & memory stable or improved

---

## Success Criteria (Overall)

* [ ] All tests pass (Puppeteer unit + Playwright integration)
* [ ] Build completes; **bundle < 100KB** (prod)
* [ ] Dev sourcemaps work; prod maps external
* [ ] Bridge survives navigation (modern + older Chromium via fallback)
* [ ] Versioned health checks pass
* [ ] No `toString()` / string-eval anywhere
* [ ] Docs updated
* [ ] No memory leaks or dangling listeners
* [ ] No performance regressions

---
