```markdown
# Migration Plan: Bundled Bridge Injection with CDP Auto-Loading (Event-Driven, Robust)

**Branch**: `feature/bundled-bridge-injection`  
**Target**: Clean implementation (no users, no backward compatibility needed)  
**Status**: Ready to Implement

---

## Executive Summary

Migrate from `class.toString()` serialization to a pre-bundled bridge with **CDP auto-injection** into a **named isolated world**, discovered **event-driven** via `Runtime.executionContextCreated`.

**Benefits**
- **Stability**: Eliminate brittle string serialization
- **Debuggability**: Real source maps + breakpoints
- **Performance**: Bundle once; auto-inject for current and future documents
- **Reliability**: Versioned bundle + explicit health checks
- **Resilience**: Navigation guard + re-discovery without polling

**Hardening vs. baseline plan**
- Register **event listeners before** enabling CDP domains (avoid missing initial events)
- **Fallback** when `runImmediately` isn’t supported (older Chromium)
- Track and remove **script identifier** for clean teardown
- Remove **manual bridge invalidations**; the injector owns lifecycle

---

## Architecture Changes

### Current Architecture (toString)

```

src/injected/index.ts
└─ injectedCode() function
├─ Serializes classes via toString()
├─ Concatenates into single string
└─ Wrapped in IIFE with config

multi-context-browser.ts
└─ _setupIsolatedWorldForContext()
├─ Creates isolated world via CDP
├─ Calls injectedCode(config)
└─ Evaluates string in isolated context

```

**Problems**
- Bridge recreated on every navigation
- No source maps / hard to debug
- Fragile on import or bundling changes
- No versioning / health checks

### Target Architecture (Bundled + Event-Driven)

```

build/
└─ bundle-bridge.ts (new, esbuild driver)

src/injection/
├─ bridge-bundle.ts (generated at prebuild)
└─ BridgeInjector.ts (new)
├─ Page.addScriptToEvaluateOnNewDocument({ worldName, runImmediately: true })
├─ Tracks contextId via Runtime.executionContextCreated
├─ Handles navigation via Page.* events
├─ Manages bridge lifecycle (create/healthcheck)
└─ Version verification, identifier cleanup

multi-context-browser.ts
└─ Uses BridgeInjector
├─ No manual re-injection on navigation
├─ Bridge survives reloads & SPA transitions
└─ Clean separation of concerns

````

**Key fixes**
- **Event-driven discovery**: `Runtime.executionContextCreated` is the single source of truth
- **Auto-inject now + later**: `Page.addScriptToEvaluateOnNewDocument(..., { worldName, runImmediately: true })` + fallback for current doc
- **Navigation guard**: Track `Page.frameStartedLoading`, `Page.navigatedWithinDocument`, `Page.frameNavigated`, `Page.frameStoppedLoading`
- **Cleanup**: Remove auto-script by identifier on teardown

---

## Migration Phases

### Phase 1: Foundation (Bundle Generation)

**Goal**: Create bundling infrastructure

#### Step 1.1: Install dev deps

```bash
npm install --save-dev esbuild tsx
````

#### Step 1.2: Build script

**New file**: `build/bundle-bridge.ts`

```ts
import * as esbuild from 'esbuild';
import * as fs from 'fs';
import * as path from 'path';

const DEV = process.env.NODE_ENV !== 'production';

async function bundleBridge() {
  const version = getVersion();

  const result = await esbuild.build({
    entryPoints: ['src/injected/bridge-entry.ts'],
    bundle: true,
    format: 'iife',
    platform: 'browser',
    target: 'es2020',
    minify: !DEV,
    sourcemap: DEV ? 'inline' : 'external',
    sourcesContent: DEV,
    banner: {
      js: [
        `// Verdex Bridge Bundle v${version}`,
        `// Generated: ${new Date().toISOString()}`,
      ].join('\n'),
    },
    define: {
      __VERSION__: JSON.stringify(version),
    },
    write: false,
  });

  const bundleCode = result.outputFiles[0].text;

  const bundleModule = `/**
 * Auto-generated bridge bundle
 * DO NOT EDIT - Generated by build/bundle-bridge.ts
 */
export const BRIDGE_BUNDLE = ${JSON.stringify(bundleCode)};
export const BRIDGE_VERSION = ${JSON.stringify(version)};
`;

  fs.writeFileSync(
    path.join(__dirname, '../src/injection/bridge-bundle.ts'),
    bundleModule
  );

  console.log('✅ Bridge bundle generated');
  console.log(`   Size: ${(bundleCode.length / 1024).toFixed(2)} KB`);
  console.log(`   Version: ${version}`);
}

function getVersion(): string {
  const pkg = JSON.parse(
    fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8')
  );
  return pkg.version;
}

bundleBridge().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

#### Step 1.3: Bridge entry point

**New file**: `src/injected/bridge-entry.ts`

```ts
/**
 * Entry point for bundled bridge injection
 * Bundled and injected into a named isolated world.
 */

import { BridgeFactory } from './bridge/BridgeFactory.js';
import type { BridgeConfig, IBridge } from './types/index.js';

// Replaced at build time by esbuild `define`
export const __VERDEX_BRIDGE_VERSION__ = __VERSION__ as string;

export function createBridge(config?: BridgeConfig): IBridge {
  return BridgeFactory.create(config);
}

// Expose factory to the *named isolated world* only
(function expose() {
  const g = globalThis as any;
  g.__VerdexBridgeFactory__ = {
    create: createBridge,
    version: __VERDEX_BRIDGE_VERSION__,
  };
})();
```

#### Step 1.4: NPM scripts

```json
{
  "scripts": {
    "prebuild": "tsx build/bundle-bridge.ts",
    "build": "npm run prebuild && rm -rf dist && tsc",
    "dev": "NODE_ENV=development tsx build/bundle-bridge.ts && tsx src/index.ts",
    "bundle:watch": "NODE_ENV=development tsx --watch build/bundle-bridge.ts"
  }
}
```

**Validation**

* [ ] `npm run prebuild` generates `src/injection/bridge-bundle.ts`
* [ ] Bundle includes dependencies
* [ ] Source maps present in dev
* [ ] Bundle size reasonable (<100 KB in prod)

---

## Critical Implementation Notes

### Version Replacement

`__VERSION__` in `bridge-entry.ts` is replaced via esbuild `define`. The generated module exports `BRIDGE_VERSION` for health checks.

### Auto-Injection Timing (with fallback)

Preferred path:

```ts
Page.addScriptToEvaluateOnNewDocument({
  source: BRIDGE_BUNDLE,
  worldName,                 // named isolated world
  includeCommandLineAPI: false,
  runImmediately: true       // run now + all future documents (when supported)
});
```

If `runImmediately` is not supported, **fallback** by creating the world and `Runtime.evaluate` the bundle once for the current document. Future documents remain covered by the registered script.

### Event-Driven World Discovery

* Register CDP **listeners before** `Page.enable`/`Runtime.enable`
* Use `Runtime.executionContextCreated` to capture the context for `{ worldName, topFrame }`
* Optionally key by `auxData.frameId` for future iframe support

### Navigation Guard

Set `navigationInProgress = true` on:

* `Page.frameStartedLoading` (top frame)
* `Page.navigatedWithinDocument` (top frame)
* `Page.frameNavigated` (top frame)

Clear when:

* You receive `Runtime.executionContextCreated` for your `{ worldName, topFrame }`, or
* `Page.frameStoppedLoading` is seen **and** your context appears

Bridge calls block (bounded) while `navigationInProgress` is true.

### Cleanup

Store the script identifier from `addScriptToEvaluateOnNewDocument` and call `Page.removeScriptToEvaluateOnNewDocument({ identifier })` on teardown.

---

## Phase 2: Bridge Injector (CDP Integration)

**Goal**: Injection management with event-driven context tracking + robust fallbacks

**New file**: `src/injection/BridgeInjector.ts`

```ts
/**
 * Manages bridge injection lifecycle via CDP (event-driven).
 */
import type { CDPSession } from 'puppeteer';
import { BRIDGE_BUNDLE, BRIDGE_VERSION } from './bridge-bundle.js';
import type { BridgeConfig } from '../types.js';

export type InjectorOptions = {
  worldName?: string;
  config?: BridgeConfig;
  mainFrameId?: string;
};

export class BridgeInjector {
  private worldName: string;
  private config: BridgeConfig;

  private mainFrameId: string | null = null;
  private contextId: number | null = null;       // executionContextId for our world
  private bridgeObjectId: string | null = null;  // created instance
  private navigationInProgress = false;
  private contextReadyResolvers: Array<() => void> = [];
  private scriptId: string | null = null;        // addScriptToEvaluateOnNewDocument identifier

  constructor(options: InjectorOptions = {}) {
    this.worldName = options.worldName ?? 'verdex_isolated';
    this.config = options.config ?? {};
    if (options.mainFrameId) this.mainFrameId = options.mainFrameId;
  }

  async setupAutoInjection(cdp: CDPSession, mainFrameId: string): Promise<void> {
    this.mainFrameId = mainFrameId;

    // 1) LISTENERS FIRST (Runtime emits existing contexts immediately after enable)
    cdp.on('Runtime.executionContextCreated', (evt: any) => {
      const ctx = evt.context;
      const aux = ctx.auxData ?? {};
      const matchesWorld = ctx.name === this.worldName || aux.name === this.worldName;
      const matchesTop = !this.mainFrameId || !aux.frameId ? true : aux.frameId === this.mainFrameId;
      if (matchesWorld && matchesTop) {
        this.contextId = ctx.id;
        this.navigationInProgress = false;
        this.resolveContextReady();
      }
    });

    cdp.on('Page.frameStartedLoading', (evt: any) => { if (this.isTopFrame(evt.frameId)) this.onTopFrameNavigating(); });
    cdp.on('Page.navigatedWithinDocument', (evt: any) => { if (this.isTopFrame(evt.frameId)) this.onTopFrameNavigating(); });
    cdp.on('Page.frameNavigated', (evt: any) => {
      if (evt.frame && this.isTopFrame(evt.frame.id) && !evt.frame.parentId) this.onTopFrameNavigating();
    });
    cdp.on('Page.frameStoppedLoading', (_evt: any) => {
      // optional fast-path: if context already set, it's safe; otherwise executionContextCreated will resolve
    });

    // 2) ENABLE DOMAINS
    await cdp.send('Page.enable');
    await cdp.send('Runtime.enable');

    // 3) REGISTER FOR NEW DOCS (+ run now when supported)
    try {
      const { identifier } = await cdp.send('Page.addScriptToEvaluateOnNewDocument', {
        source: BRIDGE_BUNDLE,
        worldName: this.worldName,
        includeCommandLineAPI: false,
        runImmediately: true, // may be ignored on older Chromium
      });
      this.scriptId = identifier;
    } catch {
      // Keep going; we can still cover the current document via fallback below
    }

    // 4) FALLBACK: if our world hasn't appeared quickly, inject once for current doc
    let ctxAppeared = false;
    try { await this.waitForContextReady(500); ctxAppeared = true; } catch { /* timeout */ }

    if (!ctxAppeared) {
      const { executionContextId } = await cdp.send('Page.createIsolatedWorld', {
        frameId: this.mainFrameId!,
        worldName: this.worldName,
        grantUniveralAccess: false, // CDP uses this spelling
      });
      await cdp.send('Runtime.evaluate', {
        expression: BRIDGE_BUNDLE,
        contextId: executionContextId,
        returnByValue: false,
      });
    }
  }

  private isTopFrame(frameId?: string): boolean {
    return !!this.mainFrameId && frameId === this.mainFrameId;
  }

  private onTopFrameNavigating() {
    this.navigationInProgress = true;
    this.contextId = null;
    this.bridgeObjectId = null;
  }

  private async waitForContextReady(timeoutMs = 5000): Promise<void> {
    if (this.contextId && !this.navigationInProgress) return;
    let timeoutHandle: NodeJS.Timeout | null = null;
    const p = new Promise<void>((resolve, reject) => {
      const done = () => { if (timeoutHandle) clearTimeout(timeoutHandle); resolve(); };
      this.contextReadyResolvers.push(done);
      timeoutHandle = setTimeout(() => {
        reject(new Error(`Isolated world '${this.worldName}' not ready within ${timeoutMs}ms`));
      }, timeoutMs);
    });
    return p;
  }

  private resolveContextReady() {
    const resolvers = this.contextReadyResolvers.splice(0);
    resolvers.forEach((fn) => fn());
  }

  private async waitForNavToClear(maxWaitMs = 10000): Promise<void> {
    if (!this.navigationInProgress) return;
    const start = Date.now();
    while (this.navigationInProgress && Date.now() - start < maxWaitMs) {
      await new Promise((r) => setTimeout(r, 50));
    }
    if (this.navigationInProgress) {
      throw new Error('Bridge unavailable: navigation taking too long');
    }
  }

  async getBridgeHandle(cdp: CDPSession): Promise<string> {
    await this.waitForNavToClear();

    if (this.bridgeObjectId) {
      const alive = await this.healthCheck(cdp);
      if (alive) return this.bridgeObjectId;
      this.bridgeObjectId = null;
    }

    await this.waitForContextReady();
    if (!this.contextId) throw new Error('No execution context available for the bridge world');

    // Verify factory exists and version matches
    const { result: factoryType } = await cdp.send('Runtime.evaluate', {
      expression: 'typeof globalThis.__VerdexBridgeFactory__',
      contextId: this.contextId,
      returnByValue: true,
    });
    if (factoryType.value !== 'object') {
      throw new Error(`Bridge factory not available in context (got: ${factoryType.value})`);
    }

    const { result: versionCheck } = await cdp.send('Runtime.evaluate', {
      expression: 'globalThis.__VerdexBridgeFactory__?.version',
      contextId: this.contextId,
      returnByValue: true,
    });
    if (versionCheck.value !== BRIDGE_VERSION) {
      throw new Error(`Bridge version mismatch in context: got ${versionCheck.value}, expected ${BRIDGE_VERSION}`);
    }

    // Create bridge instance
    const { result } = await cdp.send('Runtime.evaluate', {
      expression: `(function(config){ return globalThis.__VerdexBridgeFactory__.create(config); })(${JSON.stringify(this.config)})`,
      contextId: this.contextId,
      returnByValue: false,
    });
    if (!result.objectId) throw new Error('Failed to create bridge instance (no objectId)');

    this.bridgeObjectId = result.objectId;
    return this.bridgeObjectId;
  }

  async callBridgeMethod<T = any>(cdp: CDPSession, method: string, args: any[] = []): Promise<T> {
    await this.waitForNavToClear();
    const objectId = await this.getBridgeHandle(cdp);

    const response = await cdp.send('Runtime.callFunctionOn', {
      functionDeclaration: `
        function(...args) {
          const fn = this?.[${JSON.stringify(method)}];
          if (typeof fn !== 'function') throw new Error('Bridge method not found: ' + ${JSON.stringify(method)});
          return fn.apply(this, args);
        }
      `,
      objectId,
      arguments: args.map((v) => ({ value: v })),
      returnByValue: true,
    });

    if ((response as any).exceptionDetails) {
      const d = (response as any).exceptionDetails;
      throw new Error(d.exception?.description || d.text || 'Bridge method call failed');
    }

    return (response as any).result.value as T;
  }

  async healthCheck(cdp: CDPSession): Promise<boolean> {
    try {
      if (!this.contextId) return false;
      const { result } = await cdp.send('Runtime.evaluate', {
        expression: `(function(){ return globalThis.__VerdexBridgeFactory__?.version === ${JSON.stringify(BRIDGE_VERSION)}; })()`,
        contextId: this.contextId,
        returnByValue: true,
      });
      return result.value === true;
    } catch {
      return false;
    }
  }

  reset(): void {
    this.navigationInProgress = true;
    this.contextId = null;
    this.bridgeObjectId = null;
  }

  async dispose(cdp: CDPSession): Promise<void> {
    if (this.scriptId) {
      try {
        await cdp.send('Page.removeScriptToEvaluateOnNewDocument', { identifier: this.scriptId });
      } catch { /* ignore */ }
      this.scriptId = null;
    }
  }
}
```

**Validation**

* [ ] Injector observes `Runtime.executionContextCreated` for `worldName`
* [ ] Auto-injection survives navigation and SPA transitions
* [ ] Health check returns correct version
* [ ] Bridge methods callable via `callBridgeMethod`
* [ ] **CRITICAL**: `runImmediately` used, with **fallback** implemented
* [ ] **CRITICAL**: Listeners registered before `Runtime.enable`/`Page.enable`

**Security validation**

```ts
// In page main world (not the named isolated world)
const factoryAccessible = await page.evaluate(() => {
  return typeof (globalThis as any).__VerdexBridgeFactory__;
});
if (factoryAccessible !== 'undefined') {
  throw new Error('Bridge factory leaked into main context - isolation broken');
}
```

---

## Phase 3: Integration (Update MultiContextBrowser)

### Step 3.1: Update `RoleContext` type

**File**: `src/types.ts`

```ts
import type { BridgeInjector } from './injection/BridgeInjector.js';

export type RoleContext = {
  role: string;
  browserContext: BrowserContext;
  page: Page;
  cdpSession: CDPSession;
  bridgeInjector: BridgeInjector; // NEW
  mainFrameId: string;
  defaultUrl?: string;
  createdAt: number;
  lastUsed: number;
  hasNavigated: boolean;
};
```

> Uses `type` (not `interface`), matching codebase style.

### Step 3.2: Wire the injector

**File**: `src/multi-context-browser.ts`

**Changes**

1. **Remove old injection:**

```ts
// DELETE
import { injectedCode } from './injected/index.js';
```

2. **Add injector:**

```ts
import { BridgeInjector } from './injection/BridgeInjector.js';
```

3. **Setup role context:**

```ts
private async _setupRoleContext(
  role: string,
  browserContext: BrowserContext,
  page: Page
): Promise<RoleContext> {
  const cdpSession = await page.createCDPSession();

  // Get main frame ID
  const { frameTree } = await cdpSession.send('Page.getFrameTree');
  const mainFrameId = frameTree.frame.id;

  const bridgeInjector = new BridgeInjector({
    worldName: `verdex_${role}`,
    config: this.bridgeConfig,
    mainFrameId,
  });

  await bridgeInjector.setupAutoInjection(cdpSession, mainFrameId);

  const defaultUrl = this.rolesConfig?.roles[role]?.defaultUrl;

  const context: RoleContext = {
    role,
    browserContext,
    page,
    cdpSession,
    bridgeInjector,
    mainFrameId,
    defaultUrl,
    createdAt: Date.now(),
    lastUsed: Date.now(),
    hasNavigated: false,
  };

  // Optional: belt-and-braces
  cdpSession.on('Page.frameNavigated', (event: any) => {
    if (event.frame.id === mainFrameId && !event.frame.parentId) {
      context.bridgeInjector.reset();
    }
  });

  return context;
}
```

Note (CDP teardown): cdpSession.detach() closes the DevTools Protocol session (no further Page.*/Runtime.* commands or events). Because BridgeInjector.dispose() sends Page.removeScriptToEvaluateOnNewDocument, always call dispose() before cdpSession.detach() to ensure the injected script is removed cleanly.

4. **Delete legacy `_setupIsolatedWorldForContext`** (entire method)

5. **Replace `ensureBridgeForContext`:**

```ts
private async ensureBridgeForContext(context: RoleContext): Promise<void> {
  try {
    const healthy = await context.bridgeInjector.healthCheck(context.cdpSession);
    if (!healthy) {
      // injector will recreate on demand
    }
    await context.bridgeInjector.getBridgeHandle(context.cdpSession);
  } catch (err) {
    throw new Error(
      `Failed to ensure bridge for role '${context.role}': ${
        err instanceof Error ? err.message : String(err)
      }`
    );
  }
}
```

6. **Route all bridge calls through the injector:**

```ts
async snapshot(): Promise<Snapshot> {
  const context = await this.ensureCurrentRoleContext();
  return await context.bridgeInjector.callBridgeMethod<Snapshot>(
    context.cdpSession,
    'snapshot'
  );
}
// Apply same pattern to: click, type, inspect, get_ancestors, get_siblings, get_descendants
```

7. **Update navigation**: remove manual invalidations (injector handles lifecycle).
   **Delete** any lines that set `isolatedWorldId = null` or `bridgeObjectId = null`.
// Injector now handles nav via events.

8. **Update _closeRoleContext**: cleanup order

Add `dispose()` before detaching the CDP session.

Before:

// Cleanup order matters: CDP -> Page -> Context
if (context.cdpSession) {
  await context.cdpSession.detach();
}
if (context.page && !context.page.isClosed()) {
  await context.page.close();
}
if (context.browserContext) {
  await context.browserContext.close();
}


After:

// Cleanup order matters: Injector -> CDP -> Page -> Context
if (context.bridgeInjector) {
  await context.bridgeInjector.dispose(context.cdpSession);
}
if (context.cdpSession) {
  await context.cdpSession.detach();
}
if (context.page && !context.page.isClosed()) {
  await context.page.close();
}
if (context.browserContext) {
  await context.browserContext.close();
}


Validation:

 - All browser methods work

 - Bridge survives navigation / SPA transitions

 - Multi-role contexts remain isolated

 - dispose() runs before cdpSession.detach()

 - No TS errors

 - Tests pass

---

## Phase 4: Cleanup

* Remove old injection path:

```bash
rm src/injected/index.ts
```

* Docs:

  * Update README with new architecture
  * Remove references to `toString()` serialization
  * Add JSDoc to `BridgeInjector`

**Validation**

* [ ] No references to `injectedCode()` or string-eval remain
* [ ] Build is clean
* [ ] Tests pass

---

## Phase 5: Testing & Validation

### 5.1: Unit/E2E test example (Puppeteer)

```ts
test('bundle injection with version check', async ({ /* your harness */ }) => {
  const page = /* get puppeteer page */;
  const cdp = await page.createCDPSession();

  // Listeners first
  let ctxId: number | null = null;
  cdp.on('Runtime.executionContextCreated', (evt: any) => {
    if (evt.context?.name === 'verdex_default') ctxId = evt.context.id;
  });

  await cdp.send('Runtime.enable');

  // Initialize your injector as your app does
  await setupVerdexInjectorSomehow(page);

  // Wait up to 5s for the named world
  const start = Date.now();
  while (!ctxId && Date.now() - start < 5000) {
    await new Promise((r) => setTimeout(r, 50));
  }
  expect(ctxId).toBeTruthy();

  const { result } = await cdp.send('Runtime.evaluate', {
    expression: 'globalThis.__VerdexBridgeFactory__?.version',
    contextId: ctxId!,
    returnByValue: true,
  });
  expect(result.value).toBe(BRIDGE_VERSION);
});
```

### 5.2: Manual checklist

**Basics**

* [ ] Navigate to multiple pages (hard + SPA)
* [ ] Switch roles; verify isolation
* [ ] Reload page; bridge survives
* [ ] All bridge methods work
* [ ] Teardown: Verified that BridgeInjector.dispose() runs before cdpSession.detach(); subsequent navigations in other roles don’t inherit the auto-injected script.

**Debuggability**

* [ ] Inline source maps in dev
* [ ] Breakpoints hit original TS
* [ ] Stack traces mapped

**Races**

* [ ] Rapid navigation + immediate calls → no crash
* [ ] Long ops during nav → guarded
* [ ] Concurrent calls during nav → guarded
* [ ] Version check enforced

**Security**

* [ ] Factory **not** visible in main world

**Perf**

* [ ] Latency and memory stable vs old approach

---

## Rollback Plan

```bash
git checkout main
git branch -D feature/bundled-bridge-injection
```

All changes isolated to feature branch.

---

## Success Criteria

* [ ] All tests pass
* [ ] Bundle size < 100KB (prod)
* [ ] Source maps work (dev)
* [ ] Bridge survives navigation
* [ ] Health checks verify version
* [ ] No `toString()`/string-eval
* [ ] Docs updated
* [ ] No use of nonexistent CDP APIs
* [ ] Equal or better performance

---

## Notes & Rationale

* **Event-driven correctness**: `Runtime.executionContextCreated` is the canonical signal; no polling or private APIs.
* **Named world + `runImmediately`**: guarantees the bundle runs now and on every document in that world; fallback keeps current document covered on older Chromium.
* **Isolation**: Factory is scoped to the named isolated world; main world remains clean.
* **Lifecycle ownership**: Injector centralizes nav/race handling and cleanup, removing ad-hoc invalidation logic elsewhere.

