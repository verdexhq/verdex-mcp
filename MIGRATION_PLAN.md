# Migration Plan: Bundled Bridge Injection with CDP Auto-Loading

**Branch**: `feature/bundled-bridge-injection`  
**Target**: Clean implementation (no users, no backward compatibility needed)  
**Status**: Planning Phase

---

## Executive Summary

Migrate from `class.toString()` serialization to a pre-bundled bridge with CDP auto-injection for:
- **Stability**: Eliminate serialization brittleness
- **Debuggability**: Full source maps and breakpoints
- **Performance**: Bundle once, auto-inject on every page load
- **Reliability**: Health checks and version tracking

---

## Architecture Changes

### Current Architecture (toString)
```
src/injected/index.ts
  └─ injectedCode() function
      ├─ Serializes 5 classes via toString()
      ├─ Concatenates into single string
      └─ Wrapped in IIFE with config

multi-context-browser.ts
  └─ _setupIsolatedWorldForContext()
      ├─ Creates isolated world via CDP
      ├─ Calls injectedCode(config)
      └─ Evaluates string in isolated context
```

**Problems**:
- Bridge recreated on every navigation (lines 376-378)
- No source maps or debugging support
- Fragile if import structure changes
- No health checks or version tracking

### Target Architecture (Bundled)
```
build/
  └─ bundle-bridge.ts (new)
      └─ esbuild configuration

dist/
  └─ bridge-bundle.js (generated)
      ├─ All classes bundled with dependencies
      ├─ Inline source maps
      └─ Global factory function exposed

src/injection/
  └─ BridgeInjector.ts (new)
      ├─ Loads bundle once at startup
      ├─ Auto-injects via addScriptToEvaluateOnNewDocument
      ├─ Manages bridge lifecycle
      └─ Health checks and version verification

multi-context-browser.ts
  └─ Uses BridgeInjector
      ├─ No more manual re-injection
      ├─ Bridge survives navigation
      └─ Clean separation of concerns
```

---

## Migration Phases

### **Phase 1: Foundation (Bundle Generation)**
**Estimated Time**: 30 minutes  
**Goal**: Create bundling infrastructure

#### Step 1.1: Install Dependencies
```bash
npm install --save-dev esbuild
```

#### Step 1.2: Create Bundle Configuration
**New file**: `build/bundle-bridge.ts`

```typescript
import * as esbuild from 'esbuild';
import * as fs from 'fs';
import * as path from 'path';

async function bundleBridge() {
  const version = getVersion();
  
  const result = await esbuild.build({
    entryPoints: ['src/injected/bridge-entry.ts'],
    bundle: true,
    format: 'iife',
    globalName: '__VerdexBridgeFactory__',
    platform: 'browser',
    target: 'es2020',
    minify: false, // Keep readable for debugging
    sourcemap: 'inline',
    sourcesContent: true,
    banner: {
      js: [
        '//# sourceURL=verdex-bridge.js',
        `// Verdex Bridge Bundle v${version}`,
        `// Generated: ${new Date().toISOString()}`,
      ].join('\n'),
    },
    define: {
      '__VERSION__': JSON.stringify(version), // Replace version placeholder
    },
    write: false,
  });

  // Write bundle to src/injection/bridge-bundle.ts as a constant
  const bundleCode = result.outputFiles[0].text;
  const bundleModule = `/**
 * Auto-generated bridge bundle
 * DO NOT EDIT - Generated by build/bundle-bridge.ts
 */

export const BRIDGE_BUNDLE = ${JSON.stringify(bundleCode)};
export const BRIDGE_VERSION = '${getVersion()}';
`;

  fs.writeFileSync(
    path.join(__dirname, '../src/injection/bridge-bundle.ts'),
    bundleModule
  );

  console.log('✅ Bridge bundle generated');
  console.log(`   Size: ${(bundleCode.length / 1024).toFixed(2)} KB`);
  console.log(`   Version: ${getVersion()}`);
}

function getVersion(): string {
  const pkg = JSON.parse(
    fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8')
  );
  return pkg.version;
}

bundleBridge().catch(console.error);
```

#### Step 1.3: Create Bridge Entry Point
**New file**: `src/injected/bridge-entry.ts`

```typescript
/**
 * Entry point for bundled bridge injection
 * This file is bundled and injected into isolated worlds
 */

import { BridgeFactory } from './bridge/BridgeFactory.js';
import type { BridgeConfig, IBridge } from './types/index.js';

// Export version for health checks
export const __VERDEX_BRIDGE_VERSION__ = '__VERSION__'; // Replaced at build time

/**
 * Factory function exposed to isolated world
 */
export function createBridge(config?: BridgeConfig): IBridge {
  return BridgeFactory.create(config);
}

// Self-executing initialization
if (typeof window !== 'undefined' && typeof globalThis !== 'undefined') {
  // Expose factory to global scope (for CDP access)
  (globalThis as any).__VerdexBridgeFactory__ = {
    create: createBridge,
    version: __VERDEX_BRIDGE_VERSION__,
  };
}
```

#### Step 1.4: Update package.json Scripts
```json
{
  "scripts": {
    "prebuild": "tsx build/bundle-bridge.ts",
    "build": "npm run prebuild && rm -rf dist && tsc",
    "dev": "tsx build/bundle-bridge.ts && tsx src/index.ts",
    "bundle:watch": "tsx --watch build/bundle-bridge.ts"
  }
}
```

**Validation**:
- [ ] `npm run prebuild` generates `src/injection/bridge-bundle.ts`
- [ ] Bundle includes all dependencies
- [ ] Source maps are inline
- [ ] Bundle size < 100KB

---

## Critical Implementation Notes

### **Issue 1: Version Replacement**
The `__VERSION__` placeholder in `bridge-entry.ts` must be replaced at build time using esbuild's `define` option. This ensures the bundle contains the actual version string for health checks.

### **Issue 2: Frame Navigation Race Condition**
When navigation occurs, there's a window where:
1. `frameNavigated` event fires → `reset()` called
2. Old bridge methods still in-flight
3. Methods try to use invalidated `objectId` → crash

**Solution**: Add `navigationInProgress` flag:
- Set to `true` on `reset()`
- `callBridgeMethod` waits for flag to clear
- `getBridgeHandle` clears flag after world is ready

### **Issue 3: Auto-Injection Timing**
`addScriptToEvaluateOnNewDocument` queues the bundle, but it's not immediately available. We must wait for the isolated world to actually be created before calling bridge methods.

**Solution**: Add `waitForIsolatedWorld()` method that:
- Polls `Runtime.getExecutionContexts` for our named world
- Retries with exponential backoff (max 5 seconds)
- Throws clear error if world never appears

---

### **Phase 2: Bridge Injector (CDP Integration)**
**Estimated Time**: 45 minutes  
**Goal**: Create injection management system

#### Step 2.1: Create BridgeInjector Class
**New file**: `src/injection/BridgeInjector.ts`

```typescript
/**
 * Manages bridge injection lifecycle via CDP
 */

import type { CDPSession } from 'puppeteer';
import { BRIDGE_BUNDLE, BRIDGE_VERSION } from './bridge-bundle.js';
import type { BridgeConfig } from '../types.js';

export interface InjectorOptions {
  worldName?: string;
  config?: BridgeConfig;
}

export class BridgeInjector {
  private worldName: string;
  private config: BridgeConfig;
  private isolatedWorldId: number | null = null;
  private bridgeObjectId: string | null = null;
  private navigationInProgress: boolean = false; // NEW: Navigation guard

  constructor(options: InjectorOptions = {}) {
    this.worldName = options.worldName || 'verdex_isolated';
    this.config = options.config || {};
  }

  /**
   * Setup auto-injection for a CDP session
   * Bridge will be automatically loaded on every new document
   */
  async setupAutoInjection(
    cdpSession: CDPSession,
    mainFrameId: string
  ): Promise<void> {
    // Auto-inject on every new document (survives navigation)
    await cdpSession.send('Page.addScriptToEvaluateOnNewDocument', {
      source: BRIDGE_BUNDLE,
      worldName: this.worldName,
      includeCommandLineAPI: false,
    });

    // Also inject into current document if it exists
    await this.injectIntoCurrentDocument(cdpSession, mainFrameId);
  }

  /**
   * Inject bridge into current document
   */
  private async injectIntoCurrentDocument(
    cdpSession: CDPSession,
    mainFrameId: string
  ): Promise<void> {
    try {
      // Create isolated world
      const { executionContextId } = await cdpSession.send(
        'Page.createIsolatedWorld',
        {
          frameId: mainFrameId,
          worldName: this.worldName,
          grantUniveralAccess: false,
        }
      );

      this.isolatedWorldId = executionContextId;

      // Inject bundle
      await cdpSession.send('Runtime.evaluate', {
        expression: BRIDGE_BUNDLE,
        contextId: executionContextId,
        returnByValue: false,
      });

      console.log(`🔧 Bridge injected (v${BRIDGE_VERSION})`);
    } catch (error) {
      console.error('Failed to inject bridge:', error);
      throw error;
    }
  }

  /**
   * Get or create bridge instance
   * Waits for isolated world to be ready after navigation
   */
  async getBridgeHandle(cdpSession: CDPSession): Promise<string> {
    if (this.bridgeObjectId && !this.navigationInProgress) {
      // Check if existing bridge is still alive
      const isAlive = await this.healthCheck(cdpSession);
      if (isAlive) {
        return this.bridgeObjectId;
      }
      // Bridge died, recreate
      this.bridgeObjectId = null;
      this.isolatedWorldId = null;
    }

    // Wait for isolated world to be ready (especially after navigation)
    await this.waitForIsolatedWorld(cdpSession);
    
    // Navigation is complete, clear flag
    this.navigationInProgress = false;

    // Create new bridge instance
    return this.createBridgeInstance(cdpSession);
  }

  /**
   * Wait for isolated world to be created (after navigation or initial load)
   */
  private async waitForIsolatedWorld(cdpSession: CDPSession): Promise<void> {
    if (this.isolatedWorldId) {
      // Already have world ID, verify it still exists
      try {
        await cdpSession.send('Runtime.evaluate', {
          expression: '1',
          contextId: this.isolatedWorldId,
        });
        return; // World exists, we're good
      } catch {
        // World is gone, need to find new one
        this.isolatedWorldId = null;
      }
    }

    // Wait for isolated world to appear
    const maxRetries = 50; // 5 seconds max
    let retries = 0;
    
    while (retries < maxRetries) {
      try {
        const { contexts } = await cdpSession.send('Runtime.getExecutionContexts');
        const isolatedContext = contexts.find(
          (ctx: any) => ctx.name === this.worldName
        );
        
        if (isolatedContext) {
          this.isolatedWorldId = isolatedContext.id;
          console.log(`✅ Isolated world ready: ${this.worldName} (contextId: ${isolatedContext.id})`);
          return;
        }
      } catch (error) {
        console.warn('Failed to get execution contexts:', error);
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
      retries++;
    }
    
    throw new Error(
      `Isolated world '${this.worldName}' not ready after ${maxRetries * 100}ms. ` +
      'This may indicate addScriptToEvaluateOnNewDocument failed.'
    );
  }

  /**
   * Create bridge instance by calling factory
   */
  private async createBridgeInstance(cdpSession: CDPSession): Promise<string> {
    if (!this.isolatedWorldId) {
      throw new Error('Bridge not injected - call setupAutoInjection first');
    }

    // Verify factory is available before creating instance
    const { result: factoryCheck } = await cdpSession.send('Runtime.evaluate', {
      expression: 'typeof globalThis.__VerdexBridgeFactory__',
      contextId: this.isolatedWorldId,
      returnByValue: true,
    });

    if (factoryCheck.value !== 'object') {
      throw new Error(
        `Bridge factory not available (got: ${factoryCheck.value}). ` +
        'Bundle may not have executed in isolated world.'
      );
    }

    const { result } = await cdpSession.send('Runtime.evaluate', {
      expression: `
        (function(config) {
          if (!globalThis.__VerdexBridgeFactory__) {
            throw new Error('Bridge factory not found');
          }
          return globalThis.__VerdexBridgeFactory__.create(config);
        })(${JSON.stringify(this.config)})
      `,
      contextId: this.isolatedWorldId,
      returnByValue: false,
    });

    if (!result.objectId) {
      throw new Error('Failed to create bridge instance - no objectId returned');
    }

    this.bridgeObjectId = result.objectId;
    console.log(`✅ Bridge instance created (v${BRIDGE_VERSION})`);
    return result.objectId;
  }

  /**
   * Health check: verify bridge is loaded and functional
   */
  async healthCheck(cdpSession: CDPSession): Promise<boolean> {
    try {
      if (!this.isolatedWorldId) {
        return false;
      }

      const { result } = await cdpSession.send('Runtime.evaluate', {
        expression: `
          (function() {
            return globalThis.__VerdexBridgeFactory__?.version === '${BRIDGE_VERSION}';
          })()
        `,
        contextId: this.isolatedWorldId,
        returnByValue: true,
      });

      return result.value === true;
    } catch {
      return false;
    }
  }

  /**
   * Call bridge method
   * Handles navigation race conditions by waiting for bridge to be ready
   */
  async callBridgeMethod(
    cdpSession: CDPSession,
    method: string,
    args: any[] = []
  ): Promise<any> {
    // Wait for any in-progress navigation to complete
    const maxWait = 100; // 10 seconds max
    let waited = 0;
    while (this.navigationInProgress && waited < maxWait) {
      await new Promise(resolve => setTimeout(resolve, 100));
      waited++;
    }
    
    if (this.navigationInProgress) {
      throw new Error('Bridge unavailable: navigation taking too long');
    }

    // Get bridge handle (will wait for isolated world if needed)
    const bridgeObjectId = await this.getBridgeHandle(cdpSession);

    const response = await cdpSession.send('Runtime.callFunctionOn', {
      functionDeclaration: `
        function(...args) {
          return this.${method}(...args);
        }
      `,
      objectId: bridgeObjectId,
      arguments: args.map((arg) => ({ value: arg })),
      returnByValue: true,
    });

    if (response.exceptionDetails) {
      throw new Error(
        response.exceptionDetails.exception?.description ||
          response.exceptionDetails.text ||
          'Bridge method call failed'
      );
    }

    return response.result.value;
  }

  /**
   * Reset injector state (for navigation)
   * Sets navigation flag to prevent race conditions with in-flight bridge calls
   */
  reset(): void {
    this.navigationInProgress = true;
    this.isolatedWorldId = null;
    this.bridgeObjectId = null;
  }
}
```

**Validation**:
- [ ] Injector creates isolated world
- [ ] Auto-injection survives page navigation
- [ ] Health check returns correct version
- [ ] Bridge methods callable via callBridgeMethod
- [ ] **CRITICAL**: Version replacement works (check bundle contains actual version)
- [ ] **CRITICAL**: Navigation race condition handled (rapid navigate + click doesn't crash)
- [ ] **CRITICAL**: `waitForIsolatedWorld()` succeeds after navigation
- [ ] **CRITICAL**: `navigationInProgress` flag prevents concurrent calls during navigation

---

### **Phase 3: Integration (Update MultiContextBrowser)**
**Estimated Time**: 60 minutes  
**Goal**: Replace toString approach with BridgeInjector

#### Step 3.1: Update RoleContext Type
**File**: `src/types.ts`

```typescript
import type { BridgeInjector } from './injection/BridgeInjector.js';

export interface RoleContext {
  role: string;
  browserContext: BrowserContext;
  page: Page;
  cdpSession: CDPSession;
  bridgeInjector: BridgeInjector; // NEW: Replace isolatedWorldId/bridgeObjectId
  mainFrameId: string;
  defaultUrl?: string;
  createdAt: number;
  lastUsed: number;
  hasNavigated: boolean;
}
```

#### Step 3.2: Update MultiContextBrowser
**File**: `src/multi-context-browser.ts`

**Changes**:

1. **Remove old injection imports**:
```typescript
// DELETE
import { injectedCode } from "./injected/index.js";
```

2. **Add new injection import**:
```typescript
// ADD
import { BridgeInjector } from './injection/BridgeInjector.js';
```

3. **Update _setupRoleContext** (lines 126-174):
```typescript
private async _setupRoleContext(
  role: string,
  browserContext: BrowserContext,
  page: Page
): Promise<RoleContext> {
  // Get CDP session for this specific page
  const cdpSession = await page.createCDPSession();

  // Enable required CDP domains for this session
  await cdpSession.send("Runtime.enable");
  await cdpSession.send("Page.enable");
  await cdpSession.send("Network.enable");

  // Get main frame ID
  const { frameTree } = await cdpSession.send("Page.getFrameTree");
  const mainFrameId = frameTree.frame.id;

  // Create bridge injector with config
  const bridgeInjector = new BridgeInjector({
    worldName: `verdex_${role}`,
    config: this.bridgeConfig,
  });

  // Setup auto-injection (survives navigation)
  await bridgeInjector.setupAutoInjection(cdpSession, mainFrameId);

  // Get default URL from configuration if available
  const defaultUrl = this.rolesConfig?.roles[role]?.defaultUrl;

  // Create the context object
  const context: RoleContext = {
    role,
    browserContext,
    page,
    cdpSession,
    bridgeInjector, // NEW: Single injector instance
    mainFrameId,
    defaultUrl,
    createdAt: Date.now(),
    lastUsed: Date.now(),
    hasNavigated: false,
  };

  // Set up navigation listener (reset injector on navigation)
  cdpSession.on("Page.frameNavigated", (event: any) => {
    if (event.frame.id === mainFrameId && !event.frame.parentId) {
      // Reset injector state, but auto-injection keeps it alive
      context.bridgeInjector.reset();
      console.log(
        `🔄 Bridge reset for role ${role} (auto-injection will restore)`
      );
    }
  });

  return context;
}
```

4. **DELETE _setupIsolatedWorldForContext** (lines 262-293):
```typescript
// DELETE ENTIRE METHOD - No longer needed
```

5. **REPLACE ensureBridgeForContext** (lines 295-332):
```typescript
/**
 * Ensure bridge is ready (simplified - injector handles this)
 */
private async ensureBridgeForContext(context: RoleContext): Promise<void> {
  try {
    // Verify bridge health
    const isHealthy = await context.bridgeInjector.healthCheck(context.cdpSession);
    
    if (!isHealthy) {
      console.log(`⚠️ Bridge unhealthy for role ${context.role}, recreating...`);
      // Injector will handle recreation
    }
    
    // Ensure bridge handle exists (injector handles lazy creation)
    await context.bridgeInjector.getBridgeHandle(context.cdpSession);
  } catch (error) {
    throw new Error(
      `Failed to ensure bridge for role '${context.role}': ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}
```

6. **Update all bridge method calls** (snapshot, click, type, inspect, etc.):

```typescript
// BEFORE (lines 449-471):
async snapshot(): Promise<Snapshot> {
  try {
    const context = await this.ensureCurrentRoleContext();
    await this.ensureBridgeForContext(context);

    const { result } = await context.cdpSession.send(
      "Runtime.callFunctionOn",
      {
        functionDeclaration: "function() { return this.snapshot(); }",
        objectId: context.bridgeObjectId!,
        returnByValue: true,
      }
    );

    return result.value;
  } catch (error) {
    throw new Error(
      `Snapshot failed for role '${this.currentRole}': ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

// AFTER:
async snapshot(): Promise<Snapshot> {
  try {
    const context = await this.ensureCurrentRoleContext();
    return await context.bridgeInjector.callBridgeMethod(
      context.cdpSession,
      'snapshot'
    );
  } catch (error) {
    throw new Error(
      `Snapshot failed for role '${this.currentRole}': ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}
```

**Apply same pattern to**:
- `click(ref: string)` → `callBridgeMethod('click', [ref])`
- `type(ref, text)` → `callBridgeMethod('type', [ref, text])`
- `inspect(ref)` → `callBridgeMethod('inspect', [ref])`
- `get_ancestors(ref)` → `callBridgeMethod('get_ancestors', [ref])`
- `get_siblings(ref, level)` → `callBridgeMethod('get_siblings', [ref, level])`
- `get_descendants(ref, level)` → `callBridgeMethod('get_descendants', [ref, level])`

7. **Update navigate** (lines 376-378 - remove manual invalidation):
```typescript
// DELETE these lines (auto-injection handles it):
context.isolatedWorldId = null;
context.bridgeObjectId = null;
```

**Validation**:
- [ ] All browser methods work correctly
- [ ] Bridge survives navigation
- [ ] Multi-role contexts remain isolated
- [ ] No TypeScript errors
- [ ] All tests pass

---

### **Phase 4: Cleanup (Remove Old Code)**
**Estimated Time**: 15 minutes  
**Goal**: Remove toString serialization approach

#### Step 4.1: Delete Old Injection Code
```bash
# Delete old injection approach
rm src/injected/index.ts

# Update src/injected/README.md
```

#### Step 4.2: Update Comments and Documentation
- Update README.md with new architecture
- Update any inline comments referencing old approach
- Add JSDoc comments to BridgeInjector

**Validation**:
- [ ] No references to `injectedCode()` remain
- [ ] No references to `toString()` serialization
- [ ] Build completes without warnings
- [ ] All tests pass

---

### **Phase 5: Testing & Validation**
**Estimated Time**: 30 minutes  
**Goal**: Comprehensive testing of new approach

#### Step 5.1: Update Existing Tests
**File**: `tests/snapshot-generator.spec.ts`

Add test for bundle injection:
```typescript
test('bundle injection with source maps', async ({ page }) => {
  // Verify bridge is available
  const version = await page.evaluate(() => {
    return (window as any).__VerdexBridgeFactory__?.version;
  });
  
  expect(version).toBe(BRIDGE_VERSION);
});
```

#### Step 5.2: Manual Testing Checklist

**Basic Functionality**:
- [ ] Navigate to multiple pages
- [ ] Switch between roles
- [ ] Verify bridge survives page reload
- [ ] Test all bridge methods (snapshot, click, type, etc.)

**Debugging & Source Maps**:
- [ ] Verify source maps in DevTools
- [ ] Set breakpoint in original source file
- [ ] Check error stack traces point to source
- [ ] Open DevTools Sources → see `verdex-bridge.js` with original structure

**Critical Race Condition Tests**:
- [ ] **Rapid navigation test**: Navigate → immediately call snapshot (should not crash)
- [ ] **Mid-flight navigation**: Start long operation → navigate away → verify graceful handling
- [ ] **Concurrent calls during navigation**: Multiple snapshot() calls during page load
- [ ] **Version verification**: Check bundle contains actual version (not `__VERSION__` placeholder)
- [ ] **World creation timeout**: Navigate to slow-loading page → verify wait succeeds
- [ ] **Bridge resurrection**: Kill bridge → next method call should auto-recreate

#### Step 5.3: Performance Testing
- [ ] Measure bundle injection time vs toString
- [ ] Verify memory usage similar or better
- [ ] Confirm no performance regressions

---

## Rollback Plan

If migration fails:

```bash
# Return to main branch
git checkout main

# Delete migration branch
git branch -D feature/bundled-bridge-injection
```

All changes are isolated to the feature branch. No impact on main.

---

## Success Criteria

- [ ] All tests pass
- [ ] Bundle size < 100KB
- [ ] Source maps work in DevTools
- [ ] Bridge survives navigation
- [ ] Health checks verify bridge version
- [ ] No toString() references remain
- [ ] Documentation updated
- [ ] Performance equal or better

---

## Estimated Total Time

**2.5 - 3 hours** for complete migration with testing

---

## Next Steps

1. Review this migration plan
2. Execute Phase 1 (Foundation)
3. Validate bundle generation
4. Proceed to Phase 2 (Injector)
5. Continue through remaining phases

---

**Questions or concerns?** Review each phase and adjust as needed before starting implementation.

